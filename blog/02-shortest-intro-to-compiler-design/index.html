<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Shortest introduction to the compiler design | gsomix&#39;s blog</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/rss.xml">RSS</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Shortest introduction to the compiler design</span></h1>

<h2 class="date">2018/12/21</h2>
</div>

<main>
<p><em>Authors: Peter Sovietov, Evgeniy Andreev</em></p>
<p><em>This article is part of <a href="https://sergeytihon.com/2018/10/22/f-advent-calendar-in-english-2018/">F# Advent calendar in English 2018</a>. You may find original article in Russian with Python examples <a href="https://github.com/true-grue/Compiler-Development/wiki/%D0%9A%D1%80%D0%B0%D1%82%D1%87%D0%B0%D0%B9%D1%88%D0%B5%D0%B5-%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-(Python)">here</a>.</em></p>
<h2 id="introduction">Introduction</h2>
<p>Let&rsquo;s build a compiler of arithmetic expressions in F#. The compiler should translate source code written in Reverse Polish notation (<a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">RPN</a>) to an intermediate representation (IR) suitable for a stack machine. However, we&rsquo;re not going to build an IR interpreter as you might think. Instead we are going to translate the IR right into C language code!</p>
<h2 id="syntactic-analysis">Syntactic analysis</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#00f">type</span> <span style="color:#2b91af">IR</span> =
    | Push <span style="color:#00f">of</span> int
    | Op <span style="color:#00f">of</span> <span style="color:#2b91af">string</span>

<span style="color:#00f">let</span> scan (source: <span style="color:#2b91af">string</span>) =
    <span style="color:#00f">let</span> tokens = source.Split <span style="color:#a31515">&#39; &#39;</span>
    [ <span style="color:#00f">for</span> tok <span style="color:#00f">in</span> tokens -&gt; 
        <span style="color:#00f">match</span> Int32.TryParse tok <span style="color:#00f">with</span>
        | <span style="color:#00f">true</span>, num -&gt; Push num
        | _ -&gt; Op tok  
    ]
</code></pre></div><p>What are we doing here? The <code>scan</code> function takes a line from the user in RPN, e.g. <code>2 2 +</code>. Basically it is both the lexer and the parser of our compiler. There are various approaches: lexer and parser might be separated (e.g. generated by <a href="https://fsprojects.github.io/FsLexYacc/">FsLex and FsYacc</a>) or combined (e.g. implemented with parser combinators library, <a href="http://www.quanttec.com/fparsec/">FParsec</a>). Output of the <code>scan</code> function is the IR, a list of stack machine operations modeled with a discriminated union:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp">[ Push 2; 
  Push 2; 
  Op <span style="color:#a31515">&#34;+&#34;</span>
]
</code></pre></div><p>OK, this is already a working compiler, just not a serious one. For example, it&rsquo;s possible to push incorrect operations onto the stack, so we need to introduce another discriminated union (like <code>IR</code>) for the possible operations in our compiler. Let&rsquo;s leave that as an excercise. Don&rsquo;t forget that we are going to generate C code as output!</p>
<h2 id="translation-into-c-code">Translation into C code</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#00f">let</span> trans (ir: IR <span style="color:#2b91af">list</span>) =
    [ <span style="color:#00f">for</span> instr <span style="color:#00f">in</span> ir <span style="color:#00f">do</span>
        <span style="color:#00f">match</span> instr <span style="color:#00f">with</span>
        | Push value -&gt; 
            <span style="color:#00f">yield</span> sprintf <span style="color:#a31515">&#34;  st[sp] = %d;&#34;</span> value
            <span style="color:#00f">yield</span> <span style="color:#a31515">&#34;  sp += 1;&#34;</span>
        | Op op -&gt; 
            <span style="color:#00f">yield</span> sprintf <span style="color:#a31515">&#34;  st[sp - 2] = st[sp - 2] %s st[sp - 1];&#34;</span> op
            <span style="color:#00f">yield</span> <span style="color:#a31515">&#34;  sp -= 1;&#34;</span> 
    ] |&gt; String.concat <span style="color:#a31515">&#34;</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#34;</span>
</code></pre></div><p>What&rsquo;s going on? The <code>trans</code> function uses pattern matching to translate a list of IR instructions into C code. Pattern matching is a very convenient feature for compiler implementation. Let&rsquo;s see the output for the <code>2 2 +</code> expression.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">  st[sp] = 2;
  sp += 1;
  st[sp] = 2;
  sp += 1;
  st[sp - 2] = st[sp - 2] + st[sp - 1];
  sp -= 1;
</code></pre></div><p>The <code>st</code> array is our stack, <code>sp</code> is the pointer to the last element of the stack. What&rsquo;s left? We need some boilerplate C code for compilation by real C compiler.</p>
<h1 id="our-first-compiler">Our first compiler</h1>
<p>Let&rsquo;s just put all things together:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#00f">open</span> System

<span style="color:#00f">let</span> [&lt;Literal&gt;] ST_SIZE = 100
<span style="color:#00f">let</span> [&lt;Literal&gt;] C_CODE = <span style="color:#a31515">&#34;&#34;&#34;#include &lt;stdio.h&gt;
</span><span style="color:#a31515">  int main(int argc, char** argv) {{ 
</span><span style="color:#a31515">  int st[{0}], sp = 0;
</span><span style="color:#a31515">{1}
</span><span style="color:#a31515">  printf(&#34;%d\n&#34;, st[sp - 1]);
</span><span style="color:#a31515">  return 0;
</span><span style="color:#a31515">}}&#34;&#34;&#34;</span>

<span style="color:#00f">type</span> <span style="color:#2b91af">IR</span> =
    | Push <span style="color:#00f">of</span> int
    | Op <span style="color:#00f">of</span> <span style="color:#2b91af">string</span>

<span style="color:#00f">let</span> scan (source: <span style="color:#2b91af">string</span>) =
    <span style="color:#00f">let</span> tokens = source.Split <span style="color:#a31515">&#39; &#39;</span>
    [ <span style="color:#00f">for</span> tok <span style="color:#00f">in</span> tokens -&gt; 
        <span style="color:#00f">match</span> Int32.TryParse tok <span style="color:#00f">with</span>
        | <span style="color:#00f">true</span>, num -&gt; Push num
        | _ -&gt; Op tok  
    ]

<span style="color:#00f">let</span> trans (ir: IR <span style="color:#2b91af">list</span>) =
    [ <span style="color:#00f">for</span> instr <span style="color:#00f">in</span> ir <span style="color:#00f">do</span>
        <span style="color:#00f">match</span> instr <span style="color:#00f">with</span>
        | Push value -&gt; 
            <span style="color:#00f">yield</span> sprintf <span style="color:#a31515">&#34;  st[sp] = %d;&#34;</span> value
            <span style="color:#00f">yield</span> <span style="color:#a31515">&#34;  sp += 1;&#34;</span>
        | Op op -&gt; 
            <span style="color:#00f">yield</span> sprintf <span style="color:#a31515">&#34;  st[sp - 2] = st[sp - 2] %s st[sp - 1];&#34;</span> op
            <span style="color:#00f">yield</span> <span style="color:#a31515">&#34;  sp -= 1;&#34;</span> 
    ] |&gt; String.concat <span style="color:#a31515">&#34;</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#34;</span>

<span style="color:#00f">let</span> rpnToC (source: <span style="color:#2b91af">string</span>) = 
    <span style="color:#00f">let</span> code = source |&gt; scan |&gt; trans
    String.Format(C_CODE, ST_SIZE, code)

printfn <span style="color:#a31515">&#34;%s&#34;</span> (rpnToC <span style="color:#a31515">&#34;2 2 + 3 -&#34;</span>)
</code></pre></div><p>The <code>rpnToC</code> function is our compilation pipeline. Literally! What&rsquo;s the output?</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">#include</span> <span style="color:#00f">&lt;stdio.h&gt;</span><span style="color:#00f">
</span><span style="color:#00f"></span><span style="color:#2b91af">int</span> main(<span style="color:#2b91af">int</span> argc, <span style="color:#2b91af">char</span>** argv) {
  <span style="color:#2b91af">int</span> st[100], sp = 0;
  st[sp] = 2;
  sp += 1;
  st[sp] = 2;
  sp += 1;
  st[sp - 2] = st[sp - 2] + st[sp - 1];
  sp -= 1;
  st[sp] = 3;
  sp += 1;
  st[sp - 2] = st[sp - 2] - st[sp - 1];
  sp -= 1;
  printf(<span style="color:#a31515">&#34;%d</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#34;</span>, st[sp - 1]);
  <span style="color:#00f">return</span> 0;
}
</code></pre></div><p>Let&rsquo;s talk a little bit about the result. It&rsquo;s weird that our compiler can translate only constant expressions. Clearly, we can compute it right in the compile-time, there&rsquo;s no need to translate it at all. But consider that some arguments can come into stack from outside, e.g. from command line arguments. OK, let&rsquo;s stop here. We can add command line processing to our implementation later. For now it&rsquo;s more important to understand the compiler design at high-level.</p>
<h2 id="ssa-form">SSA form</h2>
<p><a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">Static single assignment form</a> sounds important for every compiler developer. What it is?</p>
<p>For now the compiler generates plain C code and doesn&rsquo;t need a virtual machine. But why do we need to generate code working with the stack in the runtime? Let&rsquo;s replace the stack array with plain variables. For every expression we will introduce a new one, and every variable should be assigned just once. Just no need to skimp on names. :)</p>
<p>And&hellip; this is SSA form! Our new compiler:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#00f">open</span> System
<span style="color:#00f">open</span> System.Text

<span style="color:#00f">let</span> [&lt;Literal&gt;] C_CODE = <span style="color:#a31515">&#34;&#34;&#34;#include &lt;stdio.h&gt;
</span><span style="color:#a31515">int main(int argc, char** argv) {{
</span><span style="color:#a31515">{0}
</span><span style="color:#a31515">  printf(&#34;%d\n&#34;, {1});
</span><span style="color:#a31515">  return 0;
</span><span style="color:#a31515">}}&#34;&#34;&#34;</span>

<span style="color:#00f">type</span> <span style="color:#2b91af">IR</span> =
    | Push <span style="color:#00f">of</span> int
    | Op <span style="color:#00f">of</span> <span style="color:#2b91af">string</span>

<span style="color:#00f">type</span> <span style="color:#2b91af">Env</span> = {
    stack: <span style="color:#2b91af">string</span> <span style="color:#2b91af">list</span>
    nameCounter: int
}

<span style="color:#00f">let</span> emptyEnv = { stack = []; nameCounter = 0 }

<span style="color:#00f">let</span> scan (source: <span style="color:#2b91af">string</span>) =
    <span style="color:#00f">let</span> tokens = source.Split <span style="color:#a31515">&#39; &#39;</span>
    [ <span style="color:#00f">for</span> tok <span style="color:#00f">in</span> tokens -&gt; 
        <span style="color:#00f">match</span> Int32.TryParse tok <span style="color:#00f">with</span>
        | <span style="color:#00f">true</span>, num -&gt; Push num
        | _ -&gt; Op tok  
    ]

<span style="color:#00f">let</span> trans (ir: IR <span style="color:#2b91af">list</span>) =
    <span style="color:#00f">let</span> transInstr (env: Env, code: StringBuilder) = <span style="color:#00f">function</span>
    | Push value -&gt; 
        <span style="color:#00f">let</span> statement = sprintf <span style="color:#a31515">&#34;  int t%d = %d;&#34;</span> env.nameCounter value
        <span style="color:#00f">let</span> code = code.AppendLine statement
        <span style="color:#00f">let</span> stack = (sprintf <span style="color:#a31515">&#34;t%d&#34;</span> env.nameCounter) :: env.stack
        { env <span style="color:#00f">with</span> stack = stack; nameCounter = env.nameCounter + 1}, code
    | Op op -&gt; 
        <span style="color:#00f">let</span> (leftOperand :: rightOperand :: stack) = env.stack
        <span style="color:#00f">let</span> statement = 
            sprintf <span style="color:#a31515">&#34;  int t%d = %s %s %s;&#34;</span> 
                env.nameCounter 
				rightOperand 
				op 
				leftOperand
        <span style="color:#00f">let</span> code = code.AppendLine statement
        <span style="color:#00f">let</span> stack = (sprintf <span style="color:#a31515">&#34;t%d&#34;</span> env.nameCounter) :: stack
        { env <span style="color:#00f">with</span> stack = stack; nameCounter = env.nameCounter + 1}, code

<span style="color:#00f">let</span> rpnToC (source: <span style="color:#2b91af">string</span>) = 
    <span style="color:#00f">let</span> env, code = source |&gt; scan |&gt; trans
    String.Format(C_CODE, code, env.stack.Head)

printfn <span style="color:#a31515">&#34;%s&#34;</span> (rpnToC <span style="color:#a31515">&#34;2 2 + 3 -&#34;</span>) 
</code></pre></div><p>Please keep in mind that there is no stack in the produced C code. The stack processing is performed in the compile-time. This is our internal stack for variables&rsquo; names (not values as in the previous version):</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#00f">type</span> <span style="color:#2b91af">Env</span> = {
    stack: <span style="color:#2b91af">string</span> <span style="color:#2b91af">list</span>
    nameCounter: int
}

<span style="color:#00f">let</span> emptyEnv = { stack = []; nameCounter = 0 }
</code></pre></div><p>The processing of the stack can be modeled through folding. This is a standard way in FP to perform stateful operations:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#00f">let</span> trans (ir: IR <span style="color:#2b91af">list</span>) =
    <span style="color:#00f">let</span> transInstr (env: Env, code: StringBuilder) = <span style="color:#00f">function</span>
    | Push value -&gt; <span style="color:#008000">(* ... *)</span>
    | Op op -&gt; <span style="color:#008000">(* ... *)</span>

    ir |&gt; List.fold transInstr (emptyEnv, StringBuilder())
</code></pre></div><p>There is also some non-safe code:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#00f">let</span> (leftOperand :: rightOperand :: stack) = env.stack
</code></pre></div><p>It fails when the stack does not contain enough elements. Clear error messages are another excercise for the reader. Compilation errors are a very important part of the compiler!</p>
<p>Final output:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">#include</span> <span style="color:#00f">&lt;stdio.h&gt;</span><span style="color:#00f">
</span><span style="color:#00f"></span><span style="color:#2b91af">int</span> main(<span style="color:#2b91af">int</span> argc, <span style="color:#2b91af">char</span>** argv) {
  <span style="color:#2b91af">int</span> t0 = 2;
  <span style="color:#2b91af">int</span> t1 = 2;
  <span style="color:#2b91af">int</span> t2 = t0 + t1;
  <span style="color:#2b91af">int</span> t3 = 3;
  <span style="color:#2b91af">int</span> t4 = t2 - t3;

  printf(<span style="color:#a31515">&#34;%d</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#34;</span>, t4);
  <span style="color:#00f">return</span> 0;
}
</code></pre></div><p>It seems like a good start for a more complicated compiler, right? We can go with <a href="http://evincarofautumn.blogspot.com/2012/02/why-concatenative-programming-matters.html">stack languages</a> like Forth, Postscript, Joy or Factor. Even statically typed functional <a href="https://kittenlang.org/">language</a> can be stack-based! Obviously another way is to increase syntax complexity. But let&rsquo;s leave all these questions for later posts.</p>
<p>We wish you success in compiler design. Merry Christmas and Happy New Year!</p>

</main>

  <footer>
  
  
  <hr/>
  Â© gsomix 2017 &ndash; 2020 | <a href="https://github.com/gsomix">Github</a>
  
  </footer>
  </body>
</html>

