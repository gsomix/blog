+++
title = "Shortest introduction to the compiler design"
description = ""

# The date of the post.
# 2 formats are allowed: YYYY-MM-DD (2012-10-02) and RFC3339 (2002-10-02T15:00:00Z)
# Do not wrap dates in quotes, the line below only indicates that there is no default date.
# If the section variable `sort_by` is set to `date`, then any page that lacks a `date`
# will not be rendered.
date = 2018-12-21

# The weight as defined in the Section page
# If the section variable `sort_by` is set to `weight`, then any page that lacks a `weight`
# will not be rendered.
weight = 0

# A draft page will not be present in prev/next pagination
draft = false

# If filled, it will use that slug instead of the filename to make up the URL
# It will still use the section path though
# slug = ""

# The path the content will appear at
# If set, it cannot be an empty string and will override both `slug` and the filename.
# The sections' path won't be used.
# It should not start with a `/` and the slash will be removed if it does
# path = ""

# Use aliases if you are moving content but want to redirect previous URLs to the
# current one. This takes an array of path, not URLs.
aliases = []

# Whether the page should be in the search index. This is only used if
# `build_search_index` is set to true in the config and the parent section
# hasn't set `in_search_index` to false in its front-matter
in_search_index = true

# Template to use to render this page
template = "page.html"

# The taxonomies for that page. The keys need to be the same as the taxonomies
# name configured in `config.toml` and the values an array of String like
# tags = ["rust", "web"]
[taxonomies]

categories = ["english"] 
tags = ["fsharp", "avalonia", "ui"] 

# Your own data
[extra]
+++

_Authors: Peter Sovietov, Evgeniy Andreev_
_This article is part of [F# Advent calendar in English 2017](https://sergeytihon.com/2017/10/22/f-advent-calendar-in-english-2017/)._

## Introduction

Let's build a compiler of arithmetic expressions in F#. The compiler should translate source code in [Reverse Polish notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation) into intermediate representation (IR) suitable for a stack machine. Usually stack is implemented in virtual stack machine. However, we're not going to build an IR interpreter as you might think. We are going to translate IR right into C language code!

## Syntactic analysis

```fsharp
type IR =
    | Push of int
    | Op of string

let scan (source: string) =
    let tokens = source.Split ' '
    [ for tok in tokens -> 
        match Int32.TryParse tok with
        | true, num -> Push num
        | _ -> Op tok  
    ]
```

What've we done here? The `scan` function takes a line from the user in RPN, e.g. `2 2 +`. Basically it is both lexer and parser of our compiler. There are various approaches: lexer and parser might be separated (e.g. generated by [FsLex and FsYacc](https://fsprojects.github.io/FsLexYacc/)) or joined (e.g. implemented with parser combinators library, [FParsec](http://www.quanttec.com/fparsec/)). Output of the `scan` function is IR, a list of stack machine operations modeled with discriminated union:

```fsharp
[ Push 2; 
  Push 2; 
  Op "+"
]
```

OK, this is already a working compiler, just not a serious one. For example, we can push incorrect operations onto the stack, so we need to introduce another discriminated union (like `IR`) for the operations possible in our compiler. Let's leave that as an excersise. Recall that we are going to generate C code as output!

## Translation into C code

```fsharp
let trans (ir: IR list) =
    [ for instr in ir do
        match instr with
        | Push value -> 
            yield sprintf "st[sp] = %d;" value
            yield "sp += 1;"
        | Op op -> 
            yield sprintf "st[sp - 2] = st[sp - 2] %s st[sp - 1];" op
            yield "sp -= 1;" 
    ] |> String.concat "\n"
```

What's going on? The `trans` function uses pattern matching to translate a list of IR instructions into C code. Pattern matching is a very convenient feature for compiler implementation. Let's see output for the `2 2 +` expression.

```fsharp
st[sp] = 2;
sp += 1;
st[sp] = 2;
sp += 1;
st[sp - 2] = st[sp - 2] + st[sp - 1];
sp -= 1;
```

The `st` array is our stack, `sp` is a pointer to the last element of the stack. What's left? We need some additional C code for compilation by real C compiler.

# Our first compiler

Let's just put all things together:

```fsharp
open System

let [<Literal>] ST_SIZE = 100
let [<Literal>] C_CODE = """#include <stdio.h>
int main(int argc, char** argv) {{ 
int st[{0}], sp = 0;
{1}
printf("%d\n", st[sp - 1]);
return 0;
}}"""

type IR =
    | Push of int
    | Op of string

let scan (source: string) =
    let tokens = source.Split ' '
    [ for tok in tokens -> 
        match Int32.TryParse tok with
        | true, num -> Push num
        | _ -> Op tok  
    ]

let trans (ir: IR list) =
    [ for instr in ir do
        match instr with
        | Push value -> 
            yield sprintf "st[sp] = %d;" value
            yield "sp += 1;"
        | Op op -> 
            yield sprintf "st[sp - 2] = st[sp - 2] %s st[sp - 1];" op
            yield "sp -= 1;" 
    ] |> String.concat "\n"

let rpnToC (source: string) = 
    let code = source |> scan |> trans
    String.Format(C_CODE, ST_SIZE, code)

printfn "%s" (rpnToC "2 2 + 3 -")
```

The `rpnToC` function is our compilation pipeline. Literally! What's the output?

```c
#include <stdio.h>
int main(int argc, char** argv) {
    int st[100], sp = 0;
    st[sp] = 2;
    sp += 1;
    st[sp] = 2;
    sp += 1;
    st[sp - 2] = st[sp - 2] + st[sp - 1];
    sp -= 1;
    st[sp] = 3;
    sp += 1;
    st[sp - 2] = st[sp - 2] - st[sp - 1];
    sp -= 1;
    printf("%d\n", st[sp - 1]);
    return 0;
}
```

Let's talk a little bit about the result. It's weird that our compiler can translate only constant expressions. Clearly, we can compute it right in the compile-time, no need to translate it at all. But consider that some arguments can come into stack from the outside. e.g. from command line arguments. OK, let's stop here. We can add command line processing to our implementation later. For now it's more important to understand compiler design at a high-level.

## SSA form

[Static single assignment form](https://en.wikipedia.org/wiki/Static_single_assignment_form) sounds important for every compiler developer. What it is? Let's go step by step.

For now the compiler generates plain C code without any need of the virtual machine. But why do we need to generate code working with the stack in the runtime? Let's replace the stack array with plain variables. We don't need to save on variables. For every expression we will introduce a new one, and every variable should be assigned just once. And... this is SSA form!

Our new compiler:

```fsharp
open System
open System.Text

let [<Literal>] C_CODE = """#include <stdio.h>
int main(int argc, char** argv) {{
{0}
printf("%d\n", {1});
return 0;
}}"""

type IR =
    | Push of int
    | Op of string

type Env = {
    stack: string list
    nameCounter: int
}

let emptyEnv = { stack = []; nameCounter = 0 }

let scan (source: string) =
    let tokens = source.Split ' '
    [ for tok in tokens -> 
        match Int32.TryParse tok with
        | true, num -> Push num
        | _ -> Op tok  
    ]

let trans (ir: IR list) =
    let transInstr (env: Env, code: StringBuilder) = function
    | Push value -> 
        let code = code.AppendLine (sprintf "int t%d = %d;" env.nameCounter value)
        let stack = (sprintf "t%d" env.nameCounter) :: env.stack
        { env with stack = stack; nameCounter = env.nameCounter + 1}, code
    | Op op -> 
        let (leftOperand :: rightOperand :: stack) = env.stack
        let code = code.AppendLine (sprintf "int t%d = %s %s %s;" env.nameCounter rightOperand op leftOperand)
        let stack = (sprintf "t%d" env.nameCounter) :: stack
        { env with stack = stack; nameCounter = env.nameCounter + 1}, code

    ir |> List.fold transInstr (emptyEnv, StringBuilder())

let rpnToC (source: string) = 
    let env, code = source |> scan |> trans
    String.Format(C_CODE, code, env.stack.Head)

printfn "%s" (rpnToC "2 2 + 3 -") 
```

Please pay attention that there is no stack in the produced C code. The stack processing performs in the compile-time. This is our internal stack for variables' names (not values as in the previous version):

```
type Env = {
    stack: string list
    nameCounter: int
}

let emptyEnv = { stack = []; nameCounter = 0 }
```

The processing of the stack can be modeled through folding. This is a standard way in FP to perform statefull operations:

```
let trans (ir: IR list) =
    let transInstr (env: Env, code: StringBuilder) = function
    | Push value -> ...
    | Op op -> ...

    ir |> List.fold transInstr (emptyEnv, StringBuilder())
```

There is also some non-safe code:

```fsharp
let (leftOperand :: rightOperand :: stack) = env.stack
```

It fails when stack contains not enough elements. This is another excersise for the reader. Compilation errors are very important part of the compiler!

Final output:

```c
#include <stdio.h>
int main(int argc, char** argv) {
    int t0 = 2;
    int t1 = 2;
    int t2 = t0 + t1;
    int t3 = 3;
    int t4 = t2 - t3;

    printf("%d\n", t4);
    return 0;
}
```

It seemsthat it's a good start for a more complicated compiler, right? We can go with stack languages (also [concatenative](http://evincarofautumn.blogspot.com/2012/02/why-concatenative-programming-matters.html)) like Forth, Postscript, Joy or Factor. [Even statically typed functional language can be stack-based!](https://kittenlang.org/) Obviously another way is to increase syntax complexity. But let's leave all these questions for later posts. We wish you success in compiler design. Merry Christmas and Happy New year!
