+++
title = "Shortest introduction to the compiler design"
description = ""

# The date of the post.
# 2 formats are allowed: YYYY-MM-DD (2012-10-02) and RFC3339 (2002-10-02T15:00:00Z)
# Do not wrap dates in quotes, the line below only indicates that there is no default date.
# If the section variable `sort_by` is set to `date`, then any page that lacks a `date`
# will not be rendered.
date = 2018-12-21

# The weight as defined in the Section page
# If the section variable `sort_by` is set to `weight`, then any page that lacks a `weight`
# will not be rendered.
weight = 0

# A draft page will not be present in prev/next pagination
draft = false

# If filled, it will use that slug instead of the filename to make up the URL
# It will still use the section path though
# slug = ""

# The path the content will appear at
# If set, it cannot be an empty string and will override both `slug` and the filename.
# The sections' path won't be used.
# It should not start with a `/` and the slash will be removed if it does
# path = ""

# Use aliases if you are moving content but want to redirect previous URLs to the
# current one. This takes an array of path, not URLs.
aliases = []

# Whether the page should be in the search index. This is only used if
# `build_search_index` is set to true in the config and the parent section
# hasn't set `in_search_index` to false in its front-matter
in_search_index = true

# Template to use to render this page
template = "page.html"

# The taxonomies for that page. The keys need to be the same as the taxonomies
# name configured in `config.toml` and the values an array of String like
# tags = ["rust", "web"]
[taxonomies]

categories = ["english"] 
tags = ["fsharp", "avalonia", "ui"] 

# Your own data
[extra]
+++

_Authors: Peter Sovietov, Evgeniy Andreev_

_This article is part of [F# Advent calendar in English 2018](https://sergeytihon.com/2018/10/22/f-advent-calendar-in-english-2018/)._

## Introduction

Let's build compiler of arithmetic expressions in F#. Compiler should translate source code in [Reverse Polish notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation) to intermediate representation (IR) suitable for a stack machine. Usually stack is implemented in virtual stack machine. However, we're not going to build IR interpreter as you might think. We are going to translate IR right to C language code!

## Syntactic analysis

```fsharp
type IR =
    | Push of int
    | Op of string

let scan (source: string) =
    let tokens = source.Split ' '
    [ for tok in tokens -> 
        match Int32.TryParse tok with
        | true, num -> Push num
        | _ -> Op tok  
    ]
```

What we've done here? Function `scan` takes line from user in RPN, e.g. `2 2 +`. Basically it is both lexer and parser of our compiler. There are different approaches: lexer and parser might be separated (e.g. generated by [FsLex and FsYacc](https://fsprojects.github.io/FsLexYacc/)) or joined (e.g. implemented with parser combinators library, [FParsec](http://www.quanttec.com/fparsec/)). Output of the `scan` is IR, list of stack machine operations modeled with discriminated union:

```fsharp
[ Push 2; 
  Push 2; 
  Op "+"
]
```

OK, this is already working compiler, just not a serious one. For example, we can push incorrect operations on the stack, so we need introduce another discriminated union (like `IR`) for possible operations in our compiler. Let's leave that as excersise. Recall we are going to write C code as output!

## Translation to C code

```fsharp
let trans (ir: IR list) =
    [ for instr in ir do
        match instr with
        | Push value -> 
            yield sprintf "st[sp] = %d;" value
            yield "sp += 1;"
        | Op op -> 
            yield sprintf "st[sp - 2] = st[sp - 2] %s st[sp - 1];" op
            yield "sp -= 1;" 
    ] |> String.concat "\n"
```

What's going on? Function `trans` uses pattern matching to translate list of IR instructions to C code. Pattern matching is very convenient feature for compiler implementation. Let's see output for `2 2 +` expression.

```fsharp
st[sp] = 2;
sp += 1;
st[sp] = 2;
sp += 1;
st[sp - 2] = st[sp - 2] + st[sp - 1];
sp -= 1;
```

Array `st` is our stack, `sp` is pointer to last element of the stack. What's left? We need some additional C code for compilation with real C compiler.

# Our first compiler

Just put all things together:

```fsharp
open System

let [<Literal>] ST_SIZE = 100
let [<Literal>] C_CODE = """#include <stdio.h>
int main(int argc, char** argv) {{ 
int st[{0}], sp = 0;
{1}
printf("%d\n", st[sp - 1]);
return 0;
}}"""

type IR =
    | Push of int
    | Op of string

let scan (source: string) =
    let tokens = source.Split ' '
    [ for tok in tokens -> 
        match Int32.TryParse tok with
        | true, num -> Push num
        | _ -> Op tok  
    ]

let trans (ir: IR list) =
    [ for instr in ir do
        match instr with
        | Push value -> 
            yield sprintf "st[sp] = %d;" value
            yield "sp += 1;"
        | Op op -> 
            yield sprintf "st[sp - 2] = st[sp - 2] %s st[sp - 1];" op
            yield "sp -= 1;" 
    ] |> String.concat "\n"

let rpnToC (source: string) = 
    let code = source |> scan |> trans
    String.Format(C_CODE, ST_SIZE, code)

printfn "%s" (rpnToC "2 2 + 3 -")
```

Function `rpnToC` is our compilation pipeline. Literally! What's an output?

```c
#include <stdio.h>
int main(int argc, char** argv) {
    int st[100], sp = 0;
    st[sp] = 2;
    sp += 1;
    st[sp] = 2;
    sp += 1;
    st[sp - 2] = st[sp - 2] + st[sp - 1];
    sp -= 1;
    st[sp] = 3;
    sp += 1;
    st[sp - 2] = st[sp - 2] - st[sp - 1];
    sp -= 1;
    printf("%d\n", st[sp - 1]);
    return 0;
}
```

Let's talk a little about the result. It's weird that our compile can translate only constant expressions. Clearly, we can compute it right in compile-time, no need to translate it at all. But consider that some arguments can go in stack outside. e.g. from command line arguments. OK, stop here. We can add command line processing to our implementation later. For now it's more important to understand compiler design at high-level.

## SSA form

[Static single assignment form](https://en.wikipedia.org/wiki/Static_single_assignment_form) sounds important for every compiler developer. What is it? Step by step.

For now compiler generates plain C code without need any virtual machine. But why we need to generate code to work with the stack in runtime? Let's replace stack array with plain variables. We don't need to save on variables. For every expression we will introduce new one, and every variable should be assigned just once. And... this is SSA form!

Our new compiler:

```fsharp
open System
open System.Text

let [<Literal>] C_CODE = """#include <stdio.h>
int main(int argc, char** argv) {{
{0}
printf("%d\n", {1});
return 0;
}}"""

type IR =
    | Push of int
    | Op of string

type Env = {
    stack: string list
    nameCounter: int
}

let emptyEnv = { stack = []; nameCounter = 0 }

let scan (source: string) =
    let tokens = source.Split ' '
    [ for tok in tokens -> 
        match Int32.TryParse tok with
        | true, num -> Push num
        | _ -> Op tok  
    ]

let trans (ir: IR list) =
    let transInstr (env: Env, code: StringBuilder) = function
    | Push value -> 
        let code = code.AppendLine (sprintf "int t%d = %d;" env.nameCounter value)
        let stack = (sprintf "t%d" env.nameCounter) :: env.stack
        { env with stack = stack; nameCounter = env.nameCounter + 1}, code
    | Op op -> 
        let (leftOperand :: rightOperand :: stack) = env.stack
        let code = code.AppendLine (sprintf "int t%d = %s %s %s;" env.nameCounter rightOperand op leftOperand)
        let stack = (sprintf "t%d" env.nameCounter) :: stack
        { env with stack = stack; nameCounter = env.nameCounter + 1}, code

    ir |> List.fold transInstr (emptyEnv, StringBuilder())

let rpnToC (source: string) = 
    let env, code = source |> scan |> trans
    String.Format(C_CODE, code, env.stack.Head)

printfn "%s" (rpnToC "2 2 + 3 -") 
```

Please pay attention, there is no stack in the produced C code. Work with the stack performs in compile-time. This is our internal stack for variables' names (not values as in previous version):

```
type Env = {
    stack: string list
    nameCounter: int
}

let emptyEnv = { stack = []; nameCounter = 0 }
```

Work with the stack can be modeled through folding. It's standard way in FP to perform statefull operations:

```
let trans (ir: IR list) =
    let transInstr (env: Env, code: StringBuilder) = function
    | Push value -> ...
    | Op op -> ...

    ir |> List.fold transInstr (emptyEnv, StringBuilder())
```

There is also some non-safe code:

```fsharp
let (leftOperand :: rightOperand :: stack) = env.stack
```

It fails when stack contains not enough elements. This is another excersise for the reader. Compilation errors are very important part of the compiler!

Final output:

```c
#include <stdio.h>
int main(int argc, char** argv) {
    int t0 = 2;
    int t1 = 2;
    int t2 = t0 + t1;
    int t3 = 3;
    int t4 = t2 - t3;

    printf("%d\n", t4);
    return 0;
}
```

It seems it good start for more complicated compiler, right? We can go with stack languages (also [concatenative](http://evincarofautumn.blogspot.com/2012/02/why-concatenative-programming-matters.html)) like Forth, Postscript, Joy or Factor. [Even statically typed functional language can be stack-based!](https://kittenlang.org/) Obviously another way is to increase syntax complexity. But let's leave all this questions for a next posts. We wish you success in compiler design. Merry Christmas and Happy New year!